---
# vim:ft=yaml
$schema: https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json

# Adapted (incl. comments) from Phidica Veia's syntax def. for Sublime Text:
# <https://github.com/Phidica/sublime-fish/blob/f838ab4/fish.sublime-syntax>
name: Friendly Interactive Shell (fish)
scopeName: source.shell.fish
fileTypes: [fish]
uuid: 73fe8880-b0d7-4073-8543-e923d65dad79

firstLineMatch: "^#!.*\\b(fish)\\b"

foldingStartMarker: "(;|^)\\s*(begin|for|function|if|switch|while)\\b.*$"
foldingStopMarker: "(;|^)\\s*end\\b.*$"

patterns:
  # Pick up '#' and "\\\n" before command-call sees them
  # Here (and within line-continuation) should be the only places that capture
  # a comment, as the '#' is treated as a special character whenever it could
  # end a line and used as the end of the command call
  - include: "#comment"
  - include: "#line-continuation"

  # The first command of a pipeline can't begin with a close parenthesis or be
  # "end". We match this so exclusively early because the base pipeline scope
  # will end immediately if either is seen by its lookahead
  - name: invalid.illegal.function-call.fish
    begin: \)|end
    end: (?=[{{param_sep}}])

  # The first character of a pipeline can't be an '&', and the base pipeline
  # scope won't be able to mark it as invalid so we have to do so here
  - name: invalid.illegal.operator.fish
    match: \&

  # Anonymous scope - Base scope pipeline, goes up until a definitive end
  # (typical control operators, or a comment to finish the line) or the
  # sequences that could be an end if we're actually inside a $self scope right
  # now (`)` and `end`)
  - begin: (?=\S)
    end: (\n)|(;)|((?<!&)&(?!&))|(?=\)|#|end)
    endCaptures:
      # Redirection uses the meta.function-call.operator prefix, so we
      # have it here too despite it being redundant
      "1": { name: meta.function-call.operator.control.newline.fish }
      "2": { name: meta.function-call.operator.control.semicolon.fish keyword.operator.control.fish }
      "3": { name: meta.function-call.operator.control.ampersand.fish keyword.operator.control.fish }
    patterns:
      - include: "#pipeline"

repository:
  comment:
    patterns:
      # A full or inline comment outside of any command call
      - name: comment.line.fish
        begin: \#
        beginCaptures:
          "0": { name: punctuation.definition.comment.fish }
        end: \n

  line-continuation:
    # This rule should be included anywhere that escaping a newline and adding
    # an arbitrary number of comment lines is permitted (which is pretty much
    # everywhere in fish)
    patterns:
      # Consume any number of alternating escaped newlines and lines which have
      # nothing on them but comments
      - begin: (?=\\\n)
        # End when an unescaped newline is seen, the first character of a line
        # isn't whitespace or a comment character or the escaped newline itself,
        # or if the next character after some consumed whitespace isn't more
        # whitespace or a comment character
        end: (?=\n)|^(?![\s\#\\])|\s(?![\s\#])
        patterns:
          - name: constant.character.escape.newline.fish
            match: \\\n

          - include: "#comment"

  pipeline:
    # The pipeline context is nonterminating, meaning that it will not consume a
    # *valid* control operator ('\n', ')', '#', ';', or '&'). It *will* consume
    # control operators that appear in invalid locations
    patterns:
      # Check for environment setting that precedes the decorators
      - include: "#command-call-environment"
      - include: "#separator-whitespace"
      - include: "#line-continuation"

      # This meta command acts as a unary operator on the command to the right,
      # but it is only allowed at the beginning of a pipeline! It can't come
      # after a pipe, so it isn't in the more general command-call-meta context.
      # If the command is followed by any form of execution that just prints
      # help text (ie, with an option or with an explicit or implicit newline),
      # then don't open the scope
      # Within fish 3.0, these two commands are "decorators" and intentionally
      # apply their logic to an entire "job conjunction" which we call a logic
      # pipeline
      - begin: (?=(and|or)\b(?!\s*[{{nl_w}};-]))
        end: (?={{op_w}})
        patterns:
          - begin: (and|or)\b(?!\s*[{{nl_s}};-])
            beginCaptures:
              "1": { name: meta.function-call.name.fish keyword.operator.word.fish meta.string.unquoted.fish }
            end: (?!{{ws_sep}}|\&|\\\n)
            patterns:
              - include: "#separator-whitespace"

              # If the command is followed by an "&", then that's invalid
              - name: invalid.illegal.operator.fish
                match: \&

              - include: "#line-continuation"

          # If the command is followed by redirection, then the redirection is
          # illegal. We let that be marked up by the pipeline context
          - include: "#pipeline"

      # The pipeline-segment context is recursive
      - include: "#pipeline-segment"

  pipeline-segment:
    # The pipeline-segment context is agnostic of where it appears in an overall
    # pipeline, but it does perform checks on what can appear after pipe/logic
    # operators (if they appear) before it will recurse into itself
    patterns:
      # Match operators (background, pipe, and redirect) which cannot start a
      # pipeline because they must be consumed within or after a pipeline
      - begin: (?=[&{{pipe_s}}]|{{redir_w}})
        # End at newline, ensure no operators or redirection after next
        # whitespace
        end: (?=\n)|(?!\s*(?:{{op_w_pipe_redir}}))
        patterns:
          - name: invalid.illegal.operator.fish
            # match: '[&{{pipe_s}}]|{{redir_w}}'
            match: (?:(?<!&)&(?!&)|(?<!\|)\|(?!\|)|(?:[0-9]+)?(?:<|>>?)|\^\^?)

      # Match commands illegal in the main context
      - name: invalid.illegal.function-call.fish
        match: (?:case|else|end)(?=[{{param_sep}}])

      # Anonymous scope - A pipeline may be one or more command calls linked by
      # pipe operators ('|', '2>|', etc) or logic operators ('&&' and '||')
      - begin: (?=[^\s#])
        # The pipeline terminates at the first encounter of any control
        # operator, but not '&&'
        end: (?={{op_w}})(?!&&)
        patterns:
          # Anonymous scope - Match the command of a pipeline segment
          # Ensure no whitespace, comments, background, piping
          - begin: (?![\s#&]|{{pipe_w}})
            end: (?={{op_w_pipe}})
            patterns:
              # Pick up the command call
              - include: "#command-call-meta"
              - include: "#command-call-standard"

          # Anonymous scope - Look for piping/logic which may lead to a second
          # command, and if it does recurse into the pipeline-segment context
          # again
          - begin: (?=&&|\|\||{{pipe_w}})
            end: (?={{op_w}}) #(?!&&)
            patterns:
              # Check for a malformed pipeline segment, however since fish 3.0 there is allowed to be a newline or comment after these
              # If logic operator would be followed by a control operator mark the logic operator invalid
              - name: invalid.illegal.operator.fish
                match: (?:&&|\|\|)(?=\s*[\){{op_s}}{{pipe_s}}])

              # If pipe would be followed by a control operator mark the pipe invalid
              - name: invalid.illegal.operator.fish
                match: '{{pipe_w}}(?=\s*[\){{op_s}}])'

              # Otherwise, say the piping/logic is okay; the tests at the start of pipeline-segment will highlight any invalid commands (eg, redirection)
              # A pipeline is permitted to continue on the next line with whitespace and unescaped newlines in between (though we can only catch one newline)
              - begin: |-
                  (?x)
                  (?:
                    ([0-9]+)?([{{redir_s}}]|>>?)
                    |
                    (\^\^?)
                  )?
                  ({{pipe_s}})
                captures:
                  "0": {name: meta.function-call.operator.pipe.fish}
                  "1": {name: constant.numeric.file-descriptor.fish}
                  "2": {name: keyword.operator.pipe.redirect.fish}
                  "3": {name: keyword.operator.pipe.redirect.fish}
                  "4": {name: keyword.operator.pipe.fish}
                end: (?={{op_w}})|(?:(&&)|(\|\|))|(?=.)
                endCaptures:
                  "1": { name: meta.function-call.operator.control.double-ampersand.fish keyword.operator.control.fish }
                  "2": { name: meta.function-call.operator.control.double-bar.fish keyword.operator.control.fish }
                patterns:
                  # After a pipe can't be an "and" or "or" that is taking
                  # another command as its parameters. This match should
                  # generally be pretty similar to the match which seeks a valid
                  # "and"/"or" in #pipeline, since the only difference is that
                  # here the same matched text is instead invalid. We can be a
                  # little simpler though, and not worry about marking an "&" as
                  # invalid since the word will be instead
                  - name: invalid.illegal.function-call.fish
                    match: (and|or)\b(?!\s*[\n;-])

                  # Elements that we can consume indefinitely between the piping and
                  # the next pipeline-segment (command call) which follows it
                  - include: "#separator-whitespace"
                  - include: "#line-continuation"
                  - include: "#comment"
                  - name: meta.function-call.operator.control.newline.ignored.fish
                    match: \n

                  # Match the next command and any piping/logic which follows it, and so on
                  - include: "#pipeline-segment"

  command-call-environment:
    patterns:
      - name: meta.function-call.environment.fish
        # Must start with a valid variable name identifier
        begin: (?=[{{id_var}}]+=)
        # Match the rest of the environment set, but mark it invalid if the
        # command call is about to end
        end: (?=[{{param_sep}}])|(?:\S+?|\(.*\))(?=\s*[\n{{op_s}}{{pipe_s}}{{redir_s}}])
        endCaptures:
          "1": { name: invalid.illegal.function-call.fish }
        patterns:
          - include: "#parameter-common"
          - name: keyword.operator.assignment.fish
            match: =
          - name: variable.parameter.fish meta.string.unquoted.fish
            match: (?=\=)

  command-call-meta:
    # These builtins take another command as parameters, hence, meta commands.
    # However, they act as regular commands if they take an option, are piped or
    # backgrounded, or in some cases are redirected - in that case, they are
    # picked up by the command-call-standard context.
    patterns:
      # These three meta commands force the parameter to behave as a standard
      # command. They stop when their subcommand is piped. Notably, if the command
      # is followed by redirection, then the redirection is legal and the command
      # just prints its help text, so in that case we avoid opening this scope so
      # that the command is caught elsewhere as a standard command.
      - begin: (?:builtin|command|exec)\b(?!\s*(?:{{op_w_pipe_redir}}|-))
        beginCaptures:
          "0": { name: meta.function-call.name.fish support.function.fish meta.string.unquoted.fish }
        end: (?={{op_w_pipe}})
        patterns:
          - include: "#separator-whitespace"
          - include: "#line-continuation"
          - include: "#command-call-standard"

      # (fish 3.1) This meta command is different, because it *must* accept a
      # valid function or command name as the arguments, and rejects options or
      # attempts to execute it alone
      # TODO: "time" is allowed after a logic pipe (eg "&&") but not a regular
      # pipe ('|'), and currently this implementation allows it to be in either
      # location. Something to fix up when you overhaul piping
      - name: meta.function-call.name.fish support.function.fish meta.string.unquoted.fish
        begin: 'time\b'
        end: (?={{op_w_pipe}})
        patterns:
          - include: "#separator-whitespace"
          - include: "#line-continuation"
          - include: "#command-call-standard"

      # This meta command acts as a unary operator on the command to the right,
      # which can also be a meta command. There is no restriction on where in a
      # pipeline this command may appear. If the command is followed by any form
      # of execution that just prints help text (ie, with an option or with an
      # explicit or implicit newline), then don't open the scope.
      # Note that both forms require whitespace separation from the next command
      - begin: (?=(not|!){{ws_sep}}(?!\s*[{{nl_w}};-]))
        end: (?={{op_w}})
        patterns:
          - begin: ((not)|(!))(?={{ws_sep}}(?!\s*[{{nl_w}};-]))
            # Still scoping '!' as a "word" operator, because it isn't as strong
            # as a control operator. It has to be followed by whitespace, ie, it
            # has to be a word!
            beginCaptures:
              "1": { name: meta.function-call.name.fish }
              "2": { name: keyword.operator.word.not.fish meta.string.unquoted.fish }
              "3": { name: keyword.operator.word.bang.fish meta.string.unquoted.fish }
            end: (?!{{ws_sep}}|\&|\\\n)
            patterns:
              - include: "#separator-whitespace"

              # If the command is followed by an "&" that's invalid and we need to
              # pick it up here
              - name: invalid.illegal.function-call.fish
                match: \&

              - include: "#line-continuation"

          # Redirection is illegal after the meta command, which is taken care of
          # by the pipeline context
          - include: "#pipeline"

  command-call-standard:
    # Check if the command is any other legal command, ie, a standard command
    patterns:
      # Anonymous scope - A complete command comprising a name element and
      # optional parameter, redirection, and comment elements
      - begin: (?=\S)
        end: |-
          (?x)
          (?# Look ahead for operators)
          (?=
            (?:
              (?# Find a control operator)
              [\n)#;&]
            |
              (?# Find a pipe operator)
              (?:(?:[0-9]+)?(?:<|>>?)|\^\^?)?\|
            )
          )
        patterns:
          # Anonymous scope - A name or block element. If a block is found,
          # everything up to the `end` command is captured here. Note that
          # redirection and process expansion can't start the element
          - begin: (?![\s<>^%])
            end: (?=[{{param_sep}}])
            patterns:
              # Look for block structures
              - include: "#command-call-standard-block"

              # Look for the alternate form of test, which uses a matching pair
              # of `[` `]`
              - begin: \[(?=[\s{{redir_s}}]|\\\n)
                beginCaptures:
                  "0":
                    { name: meta.function-call.name.fish support.function.test.begin.fish, }
                end: (\])|(\n|[;&)|].*)
                endCaptures:
                  "1": { name: meta.function-call.name.fish support.function.test.end.fish }
                  "2": { name: invalid.illegal.function-call.fish }
                patterns:
                  - include: "#separator-whitespace"
                  - include: "#line-continuation"
                  - include: "#parameter"
                  - include: "#redirection"

              # Look for loop/function control commands. We perform no checking
              # on the validity of their scope (because only allowing them in
              # the correct scope won't work if they are used within if-blocks)
              # or parameters (because fish does that during execution not
              # parsing)
              - match: (?:break|continue|return)(?=[{{param_sep}}])
                captures:
                  "0": { name: meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish }

              # Anonymous scope - A generic name element
              - begin: (?!\s)
                end: (?=[{{param_sep}}])
                patterns:
                  # A command name can't contain a command substitution. We match the whole line if no closing parenthesis is found, or until the end of the command name if the command substitution gets closed
                  # fish would match the whole command name invalid if there was a command substitution anywhere in it, but we can't look ahead that effectively
                  - name: invalid.illegal.function-call.fish
                    begin: (?=\()
                    end: (?=[{{param_sep}}])
                    patterns:
                      - begin: \(
                        end: \)|(?=[\n{{op_s}}{{pipe_s}}{{redir_s}}])

                  # Otherwise, treat the element as a fraction of a name made of arbitrary strings (which breaks at an escaped newline)
                  - name: meta.function-call.name.fish variable.function.fish
                    begin: (?!\s)
                    end: (?=[{{param_sep}}(])
                    patterns:
                      # The string scope explicitly forbids '$' so that the argument rule can pick it up as a variable expansion, but '$' is treated as a literal in command names, so we have to match it separately
                      - name: meta.string.unquoted.fish
                        match: \$

                      - include: "#string"

          # A command name can't begin with a process expansion operator
          # (however the variable expansion operator '$' is allowed)
          - name: invalid.illegal.function-call.fish
            match: \%[^{{param_sep}}]*(?=[{{param_sep}}])

          # Redirection can immediately follow the command name, without whitespace separation
          - include: "#redirection"

          # Anonymous scope - A list of parameter, redirection, or comment
          # elements. We rely on this list being separated from the command name
          # by whitespace
          - begin: (?={{ws_sep}}+)
            # Match any whitespace characters that aren't the newline
            end: (?={{op_w_pipe}})
            patterns:
              # A list of elements that does not start with an end-of-options parameter
              - begin: (?!--[{{param_sep}}])
                end: |-
                  (?x)
                  (?# Look ahead for operators or the end of options)
                  (?=
                    (?:
                      {{op_w_pipe}}
                    |
                      (?# Find a double hyphen)
                      --[{{param_sep}}]
                    )
                  )
                patterns:
                  - include: "#separator-whitespace"
                  - include: "#line-continuation"
                  - include: "#redirection"
                  - include: "#parameter"

              # A list of elements that starts with an end-of-options parameter
              - begin: (?=--[{{param_sep}}])
                end: (?={{op_w_pipe}})
                patterns:
                  # Contain just the end-of-options parameter and give it the normal scope
                  - begin: (?=--[{{param_sep}}])
                    end: (?=[{{param_sep}}])
                    patterns:
                      - include: "#parameter"

                  # A list of elements (now forcibly using arguments)
                  - begin: (?=\s)
                    end: (?={{op_w_pipe}})
                    patterns:
                      - include: "#separator-whitespace"
                      - include: "#line-continuation"
                      - include: "#redirection"
                      - include: "#argument"

  command-call-standard-block:
    patterns:
      # Block commands cannot be backgrounded, piped, or redirected
      - match: (begin|while|if|for|switch|function)\s*([&{{pipe_s}}{{redir_s}}]+)
        captures:
          "1": { name: meta.function-call.name.fish variable.function.fish meta.string.unquoted.fish }
          "2": { name: invalid.illegal.operator.fish }

      # The begin command uniquely cannot be the last command in a command substitution
      - match: (begin)\s*(\))
        captures:
          "1": { name: meta.function-call.name.fish variable.function.fish meta.string.unquoted.fish }
          "2": { name: invalid.illegal.operator.fish }

      # The begin command can be alone on a line or followed by any command that
      # doesn't start with a '-'. If a '-' is seen it shouldn't be treated as a
      # block.
      - name: meta.block.begin.fish
        begin: begin(?=\s*$|\s*[\n;]|\s+[^\s-])
        beginCaptures:
          "0": { name: meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish }
        end: end(?=$|[{{param_sep}}])
        endCaptures:
          "0": { name: meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish }
        patterns:
          - include: $self

      - name: meta.block.while.fish
        # If the command name is followed by a valid string (not anything that
        # closes the scope or a string starting with a '-') then open the scope
        begin: (?=while\s+[^{{nl_w}};-])
        end: end(?=$|[{{param_sep}}])
        endCaptures:
          "0": { name: meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish }
        patterns:
          # Anonymous scope - Capture the command name we know is there, include
          # a single instance of a pipeline, and end when an operator is seen
          - begin: while
            beginCaptures:
              "0": { name: meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish }
            end: (?=[{{op_w}}])
            patterns:
              - include: "#line-continuation"
              - include: "#pipeline"

          # Anonymous scope - Capture the operator we know is there, include the
          # base scope, and end when an `end` command is seen. Base scope
          # handles any invalid operators
          - begin: (\n)|(;)|(?=[#)&])
            beginCaptures:
              "1": { name: meta.function-call.operator.control.newline.fish }
              "2": { name: meta.function-call.operator.control.semicolon.fish keyword.operator.control.fish }
            end: (?=end(?:$|[{{param_sep}}]))
            patterns:
              - include: $self

      - name: meta.block.if.fish
        # If the command name is followed by a valid string (not anything that
        # closes the scope or a string starting with a '-') then open the scope
        begin: (?=if\s+[^{{nl_w}};-])
        end: end(?=$|[{{param_sep}}])
        endCaptures:
          "0": { name: meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish }
        patterns:
          # Note that this internal scope does not treat the closing parenthesis
          # as a control operator, because a command substitution can't end in
          # the middle of a block
          - include: "#command-call-standard-block-if-internal"

      - name: meta.block.for-in.fish
        begin: (?=for\s+[^{{nl_w}};-])
        # If the command name is followed by a valid string (not anything that
        # closes the scope or a string starting with a '-') then open the scope
        end: end(?=$|[{{param_sep}}])
        endCaptures:
          "0": { name: meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish }
        patterns:
          # Anonymous scope - Capture the command name we know is there, include
          # a single instance of a parameter (the varname), and end when the
          # whitespace after the varname is captured
          - begin: (for)(\s+)
            beginCaptures:
              "1": { name: meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish }
              "2": { name: meta.function-call.fish }
            end: \s+
            endCaptures:
              "0": { name: meta.function-call.fish }
            patterns:
              - name: meta.function-call.parameter.argument.fish
                begin: (?![{{param_sep}}])
                end: (?=[{{param_sep}}])
                patterns:
                  - include: "#line-continuation" # Eats whitespace on next line!

                  - include: "#command-substitution"

                  - name: meta.string.unquoted.fish
                    begin: (?=\$)
                    end: (?!\$)
                    patterns:
                      - include: "#variable-expansion"

                  - include: "#string-quoted"

                  # The only unquoted string should be a valid variable name identifier
                  - name: meta.string.unquoted.fish
                    match: '{{id_var}}'

                  # If we get to here, we have an illegal character for variables
                  - name: invalid.illegal.string.fish
                    match: .

              # Capture anything that a parameter explicitly rejects, which is
              # mostly operators
              - name: invalid.illegal.operator.fish
                match: \S+

          # Line continuation is allowed between the varname and "in"
          - include: "#line-continuation"

          # Anonymous scope - Capture the command name which might be there,
          # include an arbitrary number of arguments, and end when the control
          # operator is seen
          - begin: in(?=\s)
            beginCaptures:
              "0": { name: meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish }
            end: (?={{op_w}}|{{pipe_s}})
            patterns:
              - include: "#separator-whitespace"
              - include: "#line-continuation"
              - include: "#parameter-argument"

          # Anonymous scope - Capture the operator we know is there, include the
          # base scope, and end when an `end` command is seen. Base scope
          # handles any invalid operators
          - begin: (\n)|(;)|(?=[)#])
            beginCaptures:
              "1": { name: meta.function-call.operator.control.newline.fish }
              "2": { name: meta.function-call.operator.control.semicolon.fish keyword.operator.control.fish }
            end: (?=end(?:$|[{{param_sep}}]))
            patterns:
              - include: $self

          # Anything beside line continuation, "in", or a control operator is
          # invalid
          - name: invalid.illegal.function-call.fish
            match: \S+?

          - include: "#separator-whitespace"

      - name: meta.block.switch.fish
        begin: (?=switch\s+[^{{nl_w}};-])
        # If the command name is followed by a valid string (not anything that
        # closes the scope or a string starting with a '-') then open the scope
        end: end(?=$|[{{param_sep}}])
        endCaptures:
          "0": { name: meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish }
        patterns:
          # Anonymous scope - Match the valid part of the switch statement, then
          # look for an invalid part
          - begin: (?=switch)
            end: (?=[{{nl_w}};])
            patterns:
              # Anonymous scope - Capture the command name we know is there,
              # include a single instance of a parameter (the value), and end
              # when whitespace or a control operator is seen
              - begin: (switch)(\s+)
                beginCaptures:
                  "1": { name: meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish }
                  "2": { name: meta.function-call.fish }
                end: (?=[{{param_sep}}])
                patterns:
                  - include: "#line-continuation" # Eats whitespace on next line!
                  - include: "#parameter-argument"

                  # Capture anything that a parameter explicitly rejects, which
                  # is mostly operators
                  - name: invalid.illegal.operator.fish
                    match: \S+

              # Anonymous scope - Capture whitespace which might be there, match
              # any non-control-operator strings as invalid, and end when a
              # control operator is seen
              - begin: \s+
                beginCaptures:
                  "0": { name: meta.function-call.fish }
                end: (?=[{{nl_w}};])
                patterns:
                  - name: invalid.illegal.string.fish
                    match: \S+?

          # Anonymous scope - Capture the operator we know is there, include the
          # base scope, and end when an `end` command is seen. Base scope
          # handles any invalid operators
          - begin: (\n)|(;)|(?=[#)])
            beginCaptures:
              "1": { name: meta.function-call.operator.control.fish }
              "2": { name: meta.function-call.operator.control.fish keyword.operator.control.fish }
            end: (?=end(?:$|[{{param_sep}}]))
            patterns:
              # Anonymous scope - Capture the command name which might be there,
              # include an arbitrary number of arguments, and end when the
              # control operator is captured. Base scope further down handles
              # any invalid operators used to end the scope
              - begin: case(?=[{{ws_sep}}{{nl_s}}{{op_s}}])
                beginCaptures:
                  "0": { name: meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish }
                end: (\n)|(;)|(?=[)#&{{pipe_s}}]|{{redir_w}})
                endCaptures:
                  "1": { name: meta.function-call.operator.control.newline.fish }
                  "2": { name: meta.function-call.operator.control.semicolon.fish keyword.operator.control.fish }
                patterns:
                  - include: "#separator-whitespace"
                  - include: "#line-continuation"
                  - include: "#parameter-argument"

              - include: $self

      - name: meta.block.function.fish
        begin: (?=function\s+[^{{nl_w}};-])
        # If the command name is followed by a valid string (not anything that
        # closes the scope or a string starting with a '-') then open the scope
        end: end(?=$|[{{param_sep}}])
        endCaptures:
          "0": { name: meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish }
        patterns:
          # Anonymous scope - Match the defined name of the function statement,
          # then look for further parameters
          - begin: (?=function)
            end: (?={{op_w_pipe_redir}})
            patterns:
              # Anonymous scope - Capture the command name we know is there,
              # include a single instance of a parameter (the value), and end
              # when whitespace or a control operator is seen
              - begin: (function)\s+
                beginCaptures:
                  "0": { name: meta.function-call.name.fish }
                  "1": { name: keyword.control.conditional.fish meta.string.unquoted.fish }
                end: (?=[{{param_sep}}])
                patterns:
                  - include: "#line-continuation" # Eats whitespace on next line!

                  - name: invalid.illegal.string.fish
                    begin: "[|<>]"
                    end: (?=[\s);&])

                  # Anonymous scope - Start when an escaped newline isn't
                  # present, and end when whitespace or an operator is seen
                  - begin: (?!\\\n)
                    end: (?=[{{param_sep}}])
                    patterns:
                      # This is all the usual things a parameter is allowed to
                      # contain
                      - name: meta.function-call.parameter.argument.fish entity.name.function.fish
                        begin: (?![{{ws_sep}}{{nl_s}}])
                        end: (?=[{{param_sep}}])
                        patterns:
                          - include: "#parameter-common"

              # Anonymous scope - Capture whitespace which might be there, then
              # match anything normal for a command call, except redirections!
              - begin: (?={{ws_sep}})
                end: (?={{op_w_pipe_redir}})
                patterns:
                  - include: "#separator-whitespace"
                  - include: "#line-continuation"
                  - include: "#parameter"

          # Anonymous scope - Capture the operator we know is there, include the
          # base scope, and end when an `end` command is seen. Base scope
          # handles any invalid operators
          - begin: (\n)|(;)|(?=[)#&{{pipe_s}}]|{{redir_w}})
            beginCaptures:
              "1": { name: meta.function-call.operator.control.newline.fish }
              "2": { name: meta.function-call.operator.control.semicolon.fish keyword.operator.control.fish }
            end: (?=end(?:$|[{{param_sep}}]))
            patterns:
              - include: $self

  command-call-standard-block-if-internal:
    # The acceptable structure internal to an if-end block can be represented
    # recursively because anonymous scopes nest silently. If an `else` without a
    # following `if` is seen, then further `else` commands will be correctly
    # marked as invalid. This is a lot of work just to get that extra little bit
    # of functionality :)
    patterns:
      # Anonymous scope - Capture an `if` and the command up to the control
      # operator, then capture from the control operator indefinitely.
      - begin: (?=if(?:\s*\n|\s+[^\s;]))
        end: (?=end(?:$|[{{param_sep}}]))
        patterns:
          # Anonymous scope - Match the command name we know is there, include a
          # single instance of a pipeline, and end when a control operator is
          # seen
          - begin: if
            beginCaptures:
              "0": { name: meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish }
            end: (?=[\n#{{op_s}}])
            patterns:
              - include: "#line-continuation"
              - include: "#pipeline"

          # Anonymous scope - Match the operator we know is there, then include
          # the base scope or an `else` structure. Base scope handles any
          # invalid operators
          - begin: (\n)|(;)|(?=[#&])
            beginCaptures:
              "1": { name: meta.function-call.operator.control.newline.fish }
              "2": { name: meta.function-call.operator.control.semicolon.fish keyword.operator.control.fish }
            end: '(?=end(?:$|[{{param_sep}}]))'
            patterns:
              # Anonymous scope - Capture an `else` up to the control operator
              # or the start of an `if` structure, then match from the control
              # operator indefinitely or match an `if` structure
              - begin: (?=else\s*[\s;])
                end: (?=end(?:$|[{{param_sep}}]))
                patterns:
                  # Anonymous scope - Match the `else` we know is there and any
                  # comment, and mark anything besides an `if` as illegal
                  - begin: else(?=\s*[\s;])
                    beginCaptures:
                      "0": { name: meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish }
                    end: (?=[\n#{{op_s}}{{pipe_s}}]|if(?:\s*\n|\s+[^\s;]))
                    patterns:
                      - include: "#separator-whitespace"
                      - include: "#line-continuation"

                      # Anything else is illegal
                      - name: invalid.illegal.string.fish
                        match: \S+?(?=[\s{{op_s}}])

                  # Anonymous scope - Match the operator which will be there if
                  # no `if` was seen, then include the base scope which marks
                  # further `else` commands as invalid. Base scope handles any
                  # invalid operators
                  - begin: (\n)|(;)|(?=[#&|])
                    beginCaptures:
                      "1": { name: meta.function-call.operator.control.newline.fish }
                      "2": { name: meta.function-call.operator.control.semicolon.fish keyword.operator.control.fish }
                    end: (?=end(?:$|[{{param_sep}}]))
                    patterns:
                      - include: $self

                  # Match the `if` structure which will be there if no operator
                  # was seen
                  - include: "#command-call-standard-block-if-internal"

              - include: $self

  redirection:
    patterns:
      # This redirection pattern connects a file descriptor (either explicit or
      # implied) to another file descriptor. As the '&' is necessary to denote the
      # target file descriptor, this is a more strict pattern match and must be
      # attended to first
      - begin: (?=(?:[0-9]+(?:<|>>|>)|>>|\^\^|[<>^])\&)
        # Begin at any of the redirections valid for a file descriptor (the '&'
        # must be present). Note that the stderr redirect operator '^' cannot be
        # preceded by a file descriptor. The parameter and argument rules are in
        # charge of preventing '^' being treated as a redirection when it appears
        # in the middle of a word
        end: (?=[\s);&|]|(?:[0-9]+(?:<|>>|>)|>>|\^\^|[<>^])(?![&<>^]))
        # End at anything that would end a parameter, including redirections *if*
        # they are *not* this same type of redirection (ie, have an '&'), in which
        # case this scope stays open and we match the next one. The negative
        # lookahead for <>^ at the end is to keep ST2 happy (not hanging)
        patterns:
          - begin: (?:([0-9]+)(<|>>|>)|(>>|\^\^|[<>^]))(\&)\s*
            beginCaptures:
              "0": { name: meta.function-call.operator.redirection.fish }
              "1": { name: meta.string.unquoted.fish constant.numeric.file-descriptor.fish }
              "2": { name: keyword.operator.redirect.fish }
              "3": { name: keyword.operator.redirect.fish }
              "4": { name: keyword.operator.redirect.dereference.fish }
            end: ([#&]\S*)|(?![&\\])
            endCaptures:
              "0": { name: meta.function-call.operator.redirection.fish }
              "1": { name: invalid.illegal.file-descriptor.fish }
            # We have to try and catch an '&' here because if it is seen by the
            # outer end match then it will be considered a valid operator and the
            # redirection scope will immediately terminate
            patterns:
              - include: "#line-continuation" # Eats whitespace on next line

          - include: "#line-continuation"

          # Evaluates to a string which may be an integer
          - name: meta.function-call.operator.redirection.fish
            begin: (?=\()
            end: (?!\()
            patterns:
              - include: "#command-substitution"

          # Evaluates to a string which may be an integer
          - name: meta.function-call.operator.redirection.fish
            begin: (?=\$)
            end: (?!\$)
            patterns:
              - include: "#variable-expansion"

          # May be a quoted integer, which is allowed
          - name: meta.function-call.operator.redirection.fish
            begin: (?=['"])
            end: (?!['"])
            patterns:
              - include: "#string-quoted"

          - name:
              meta.function-call.operator.redirection.file-descriptor.fish
              meta.string.unquoted.fish constant.numeric.file-descriptor.fish
            match: (?:[0-9]+)(?=$|[\s);&|<>])
          - name:
              meta.function-call.operator.redirection.file-descriptor.fish
              meta.string.unquoted.fish keyword.operator.redirect.close.fish
            match: (?:-)(?=$|[\s);&|<>])

          # Anything else is illegal
          - name:
              meta.function-call.operator.redirection.fish
              invalid.illegal.file-descriptor.fish
            match: (?:\S+)

      # This redirection pattern connects a file descriptor (either explicit or
      # implied) and a file path
      - begin: (?=(?:[0-9]+(?:<|>>|>)|>>|\^\^|[<>^])\??)
        # Begin at any of the redirections valid for a file path (the '?' may
        # optionally be used to prevent clobber). See above comments on stderr
        # redirect operator '^'
        end: (?=[\s);&|]|(?:[0-9]+(?:<|>>|>)|>>|\^\^|[<>^])[&|]) # todo: watch out for redirect into pipe?
        # End at anything that would end a parameter, including redirections *if*
        # they are *not* this same type of redirection (ie, redirection into file
        # descriptor, or into pipe), in which case this scope stays open and we
        # match the next one
        patterns:
          - begin: (?:([0-9]+)(<|>>|>)|(>>|\^\^|[<>^]))(\?)?\s*
            beginCaptures:
              "0": { name: meta.function-call.operator.redirection.fish }
              "1": { name: meta.string.unquoted.fish constant.numeric.file-descriptor.fish }
              "2": { name: keyword.operator.redirect.fish }
              "3": { name: keyword.operator.redirect.fish }
              "4": { name: keyword.operator.redirect.clobber-test.fish }
            end: ((?:[#&?]|[0-9]*[<>^])\S*)|(?![&?<>^])
            endCaptures:
              "0": { name: meta.function-call.operator.redirection.fish }
              "1": { name: invalid.illegal.path.fish }
            # We have to try and catch bad operators here because if they are seen
            # by the outer end match then they will be considered valid and the
            # redirection scope will immediately terminate
            patterns:
              - include: "#line-continuation" # Eats whitespace on next line

          - include: "#line-continuation"

          # A redirection path cannot contain brace expansion
          - name:
              meta.function-call.operator.redirection.fish
              invalid.illegal.path.fish
            begin: \{|(?=\})
            end: '{{ws_sep}}|[{{nl_s}}{{op_s}}{{pipe_s}}]|\}'

          # A redirection path cannot contain wildcard expansion
          - name:
              meta.function-call.operator.redirection.fish
              invalid.illegal.path.fish
            match: '[*?]\S*'

          # Check for characters which are associated with redirection, so path
          # cannot begin with them
          - name:
              meta.function-call.operator.redirection.fish
              invalid.illegal.path.fish
            match: '[&?]|[0-9]*[<>^]\S*'

          # We reserve the meta.redirection.path scope only for redirection paths
          # which may represent literal paths
          - name:
              meta.function-call.operator.redirection.path.fish
              meta.string.unquoted.fish
              keyword.operator.tilde.fish
            match: \~

          # Use strings to build a file path, but break out if any invalid
          # elements or elements that wouldn't form a literal path are encountered
          - name: meta.function-call.operator.redirection.path.fish
            begin: (?![\s);&(|<>${}*?])
            end: (?=[\s);&(|<>${}*?])
            patterns:
              - include: "#string-quoted"

              # Should use the same patterns as the above begin/end, but also add
              # the quotes so the #string-quoted rule can handle quoted strings
              - name: meta.string.unquoted.fish
                begin: (?![\s);&(|<>${}*?]|['"])
                end: (?=[\s);&(|<>${}*?]|['"])
                patterns:
                  - include: "#string-unquoted-patterns-escapes"

          # A raw path cannot begin with '(' since this undergoes command substitution
          - name: meta.function-call.operator.redirection.fish
            begin: (?=\()
            end: (?!\()
            patterns:
              - include: "#command-substitution"

          # A raw path cannot begin with '$' since this undergoes variable expansion
          # We also make sure that variable expansion is scoped as an unquoted string, since if it appears inside quotes then it gets scoped as a quoted string and we should mirror that
          - name: meta.function-call.operator.redirection.fish meta.string.unquoted
            begin: (?=\$)
            end: (?!\$)
            patterns:
              - include: "#variable-expansion"

  redirection-to-pipe:
    patterns:
      # Mysteriously, the explicit "0<" form isn't allowed (since at least 2.7)
      # Raises the question of what this is actually doing...
      - name: meta.function-call.operator.pipe.stdin.implicit.fish
        begin: (?=<)
        end: '(<)|({{pipe_s}})' # redirection-common-op-read / pipe-common
        endCaptures:
          "1": { name: keyword.operator.redirect.read.fish }
          "2": { name: keyword.operator.pipe.fish }

      # Append form (">>") is illegal from 3.1 onwards
      - name: meta.function-call.operator.pipe.stdout.explicit.fish
        begin: (?=1>>?|>>?)
        end: '(>>)({{pipe_s}})?|(>)({{pipe_s}})?|([0-9]+)|(?=>>?)' # redirection-common-op-write / redirection-common-lhs / pipe-common
        endCaptures:
          "1": {name: keyword.operator.redirect.write.append.fish}
          "2": {name: meta.function-call.operator.pipe.stdout.implicit.fish keyword.operator.pipe.fish}
          "3": {name: keyword.operator.redirect.write.truncate.fish}
          "4": {name: meta.function-call.operator.pipe.stdout.implicit.fish keyword.operator.pipe.fish}
          "5": {name: meta.string.unquoted.fish constant.numeric.file-descriptor.fish}

      # Pipe with no redirection in front at all
      - name: meta.function-call.operator.pipe.stdout.implicit.fish
        match: (?={{pipe_s}})

      # Only the explicit truncate form ("2>") is legal from 3.1 onwards
      - name: meta.function-call.operator.pipe.stderr.explicit.fish
        begin: (?=2>>?)
        end: (>>)|(>)|([0-9]+)|(?=>>?)|({{pipe_s}}) # redirection-common-op-write / redirection-common-lhs / pipe-common
        endCaptures:
          "1": {name: keyword.operator.redirect.write.append.fish}
          "2": {name: keyword.operator.redirect.write.truncate.fish}
          "3": {name: meta.string.unquoted.fish constant.numeric.file-descriptor.fish}
          "4": {name: meta.function-call.operator.pipe.stdout.implicit.fish}
          "5": {name: keyword.operator.pipe.fish}

      - name: meta.function-call.operator.pipe.stderr.implicit.fish
        begin: (?=\^\^?)
        end: (\^\^)|(\^)|({{pipe_s}}) # redirection-common-op-write-caret / pipe-common
        endCaptures:
          "1": {name: keyword.operator.redirect.write.append.fish}
          "2": {name: keyword.operator.redirect.write.truncate.fish}
          "3": {name: keyword.operator.pipe.fish}

      # From 3.1 we gain access to the std-write form (see notes in redirection-to-file-path-lhs+op)
      - name: meta.function-call.operator.pipe.std-write.fish
        begin: (?=\&)
        end: '(\&)|({{pipe_s}})' #  / pipe-common
        endCaptures:
          "1": { name: meta.string.unquoted.fish constant.numeric.file-descriptor.fish }
          "2": {name: keyword.operator.pipe.fish}

      # Read ("<") and append form (">>") are illegal from 3.1 onwards
      - name: meta.function-call.operator.pipe.other.fish
        begin: (?=[0-9]+(?:<|>>|>))
        end: '(<)|(>>)|(>)|([0-9]+)|({{pipe_s}})' # redirection-common-op-read / redirection-common-op-write + redirection-common-lhs / pipe-common
        endCaptures:
          "1": { name: keyword.operator.redirect.read.fish }
          "2": { name: keyword.operator.redirect.write.append.fish }
          "3": { name: keyword.operator.redirect.write.truncate.fish }
          "4": { name: meta.string.unquoted.fish constant.numeric.file-descriptor.fish }
          "5": {name: keyword.operator.pipe.fish}

  separator-whitespace:
    # Fundamental structure used to separate elements of a command call; it's
    # any whitespace that isn't a newline, practically meaning spaces or tabs
    patterns:
      - name: meta.function-call.fish
        match: '{{ws_sep}}+'

  parameter:
    patterns:
      # The fish docs for `complete` define the fundamental units passed to a
      # command as "parameters", where those which start with a hyphen are
      # "options" and those which don't are "arguments".
      # Parameters are here defined as a sequence of non-operator characters
      # separated by unescaped and unscoped whitespace.

      # Order important because the parameter-argument rule doesn't exclude
      # things that look like options.
      - include: "#parameter-option"
      - include: "#parameter-argument"

  parameter-common:
    patterns:
      # The typical substitutions, expansions, and escapes allowed anywhere in a
      # parameter
      - include: "#command-substitution"

      # Give variable expansion the unquoted string scope, since if it appears
      # inside a string it gets the quoted string scope and we should mirror
      # that
      - name: meta.string.unquoted.fish
        begin: (?=\$)
        end: (?!\$)
        patterns:
          - include: "#variable-expansion"

      # Parameters are otherwise made of strings, either quoted or unquoted. The
      # string-unquoted context handles character escapes and brace expansion
      - include: "#string"

  parameter-option:
    patterns:
      # Long option (parameter starting with two hyphens)
      - name: meta.function-call.parameter.option.long.fish variable.parameter.fish
        begin: (?=--)
        end: (?=[{{param_sep}}])
        patterns:
          - name: variable.parameter.fish
            begin: --
            beginCaptures:
              "0": { name: punctuation.definition.option.long.begin.fish meta.string.unquoted.fish }
            end: (?=[{{param_sep}}=])
            patterns:
              # We mimic the parameter-common context but use a tweaked unquoted
              # string pattern which excludes '='
              - include: "#command-substitution"

              - name: meta.string.unquoted.fish
                begin: (?=\$)
                end: (?!\$)
                patterns:
                  - include: "#variable-expansion"

              - include: "#string-quoted"

              - name: meta.string.unquoted.fish
                begin: (?!['"])
                end: (?=[{{param_sep}}('"$=])
                patterns:
                  - include: "#string-unquoted-contents"

          # Consume the '=' and then use standard parameter patterns as well as
          # numerics
          - name: variable.parameter.fish punctuation.definition.option.long.separator.fish meta.string.unquoted.fish
            begin: =
            end: (?=[{{param_sep}}])
            patterns:
              - name: meta.string.unquoted.fish constant.numeric.fish
                match: '{{real}}(?=$|[{{param_sep}}])'

              - include: "#parameter-common"

      # Short option (parameter starting with one hyphen)
      - name: meta.function-call.parameter.option.short.fish variable.parameter.fish
        begin: -(?=[^{{param_sep}}])
        beginCaptures:
          "0": { name: punctuation.definition.option.short.fish meta.string.unquoted.fish }
        end: (?=[{{param_sep}}])
        patterns:
          - include: "#parameter-common"

  parameter-argument:
    # Arguments are a type of parameter never treated like options by the
    # command they are passed to.
    # This context must be entirely standalone because it is used in scopes
    # where parameters starting with hyphens are explicitly interpreted as
    # arguments rather than as options.
    patterns:
      - begin: (?![{{param_sep}}^])
        end: (?=[{{param_sep}}])
        patterns:
          # Job expansion if the whole argument is an integer
          - match: (\%)[0-9]+(?=$|[{{param_sep}}])
            captures:
              "0": { name: meta.function-call.parameter.argument.job-expansion.fish meta.string.unquoted.fish }
              "1": { name: punctuation.definition.job.fish }

          # Special process expansions. By a convention that I'm making up,
          # scope them as a type of variable
          - match: (\%)(self)(?=$|[{{param_sep}}])
            captures:
              "0": { name: meta.function-call.parameter.argument.process-expansion.self.fish meta.string.unquoted.fish }
              "1": { name: punctuation.definition.process.fish }
              "2": { name: variable.language.fish }

          - match: (\%)(last)(?=$|[{{param_sep}}])
            captures:
              "0": { name: meta.function-call.parameter.argument.process-expansion.last.fish meta.string.unquoted.fish }
              "1": { name: punctuation.definition.process.fish }
              "2": { name: variable.language.fish }

          # Normal process expansion
          - name: meta.function-call.parameter.argument.process-expansion.other.fish
            begin: \%
            beginCaptures:
              "0": { name: meta.string.unquoted.fish punctuation.definition.process.fish }
            end: (?=[{{param_sep}}])
            patterns:
              - include: "#parameter-common"

          # Treat a sequence of integers (with possible sign and decimal
          # separator) as a standalone constant. Don't do this in the
          # string-unquoted-patterns context, so that we can ensure it is a
          # string solely of numbers
          - name: meta.function-call.parameter.argument.numeric.fish meta.string.unquoted.fish constant.numeric.fish
            match: '{{real}}(?=$|[{{param_sep}}])'

          # This scope can be used by plugins to locate arguments which don't
          # *start* with command substitution or variable expansion and may
          # directly resolve to file paths. Of course, they could have command
          # substitution or variable expansion further on in them (and we do
          # include those contexts), but looking ahead for that to avoid using
          # this particular scope name is nontrivial
          - name: meta.function-call.parameter.argument.path.fish
            begin: (?![\s($])
            end: (?=[{{param_sep}}])
            patterns:
              # Home directory expansion only occurs if the '~' is at the front
              # of the argument, so check it first
              - name: meta.string.unquoted.fish keyword.operator.tilde.fish
                begin: \~
                end: (?=[{{param_sep}}])
                patterns:
                  - include: "#parameter-common"

              - include: "#parameter-common"

          # Use standard parameter patterns for whatever doesn't match the above
          - name: meta.function-call.parameter.argument.fish
            begin: (?!\s)
            end: (?=[{{param_sep}}])
            patterns:
              - include: "#parameter-common"

  command-substitution:
    patterns:
      # Capture "(...)" or "(...)[...]" which may be preceded by "$" or "\$"
      - begin: (?=(\\?\$)?\()
        end: (?![\(\[])
        patterns:
            # As of fish 3.4.0, trying to escape the "$" has no effect on
            # unquoted string command substitutions, the substitution still
            # happens and without even a "$" getting printed. To indicate this,
            # don't show the "$" as getting escaped
          - match: (\\)?(\$)
            captures:
              "0": { name: meta.parens.command-substitution.dollar.fish }
              "1": { name: constant.character.escape.fish }
              # Imitate the Bash syntax schema and scope this "$" the same as we
              # do for variable expansions
              "2": { name: punctuation.definition.variable.fish }

          - name: meta.parens.command-substitution.fish
            begin: \(
            beginCaptures:
              "0": { name: punctuation.section.parens.begin.fish }
            end: \)
            endCaptures:
              "0": { name: punctuation.section.parens.end.fish }
            patterns:
              # The inside of a command substitution is indistinguishable from a
              # global scope
              - include: $self

          - include: "#index-expansion"

  variable-expansion:
    patterns:
      - include: "#variable-expansion-illegal"

      - include: "#variable-builtin"

      # Capture "$foo" or "$foo[]" or "$$foo[][]" etc
      - name: meta.variable-expansion.fish
        begin: (?=\$)
        end: (?=[^\$\[])
        patterns:
          # Match any depth of recursive variable expansions
          - include: "#variable-expansion-simple"

          # Match any number of consecutive index expansions
          - include: "#index-expansion"

  variable-expansion-simple:
    patterns:
      - name: variable.other.fish
        begin: \$
        beginCaptures:
          "0": { name: punctuation.definition.variable.fish }
        # Variables can only be made of word characters or other variables
        end: (?=[^\${{id_var}}])(?!\\\n)
        patterns:
          - name: constant.character.escape.newline.fish
            match: \\\n
          - include: "#variable-expansion-illegal"
          - include: "#variable-expansion-simple"

  variable-expansion-illegal:
    patterns:
      # A lone '$' in a scope, or an attempt to expand a variable starting with
      # a nonword character, is an error. These boundaries are the same as for
      # meta.string.unquoted.
      - name: invalid.illegal.variable-expansion.fish
        match: \$(?:(?=[,'"\]}{{param_sep}}])|[^\${{id_var}}][^$,'"\]}{{param_sep}}]*)

  variable-builtin:
    patterns:
      - # https://fishshell.com/docs/current/language.html#special-variables
        name: variable.language.fish
        match: "(\\$)(PATH|CDPATH|FISH_DEBUG|FISH_DEBUG_OUTPUT|LANG|LC_(ALL|COLLATE|CTYPE|MESSAGES|MONETARY|NUMERIC)|fish_color_(normal|command|keyword|quote|redirection|end|error|param|valid_path|option|comment|selection|operator|escape|autosuggestion|cwd|cwd_root|user|host|host_remote|status|cancel|search_match)|fish_ambiguous_width|fish_emoji_width|fish_autosuggestion_enabled|fish_handle_reflow|fish_key_bindings|fish_escape_delay_ms|fish_greeting|fish_history|fish_trace|fish_user_paths|umask|BROWSER|_|argv|CMD_DURATION|COLUMNS|LINES|fish_kill_signal|fish_killring|fish_pid|history|HOME|hostname|IFS|last_pid|PWD|pipestatus|SHLVL|status|status_generation|USER|EUID|version|FISH_VERSION|__fish_bin_dir|__fish_config_dir|__fish_data_dir|__fish_help_dir|__fish_sysconf_dir|__fish_user_data_dir)\\b"
        captures:
          "1": { name: punctuation.definition.variable.fish }

  index-expansion:
    patterns:
      - name: meta.brackets.index-expansion.fish
        # Note that command substitution should only have a single index expansion
        begin: \[
        beginCaptures:
          "0": { name: punctuation.section.brackets.begin.fish }
        end: \]
        endCaptures:
          "0": { name: punctuation.section.brackets.end.fish }

        # The number of index expansion parameter lists `[...]` should always be
        # less than or equal to the number of variable expansion operators `$`.
        # Unfortunately, we can do nothing to include that in a tmLanguage. With
        # a *.sublime-syntax and a scope stack it could be done. As it stands,
        # "$$foo[...]" is the deepest that we can accurately highlight.
        # In other words, the anonymous scope which contains the variable and
        # the index expansion parameter list should only be allowed to contain a
        # single copy of each of those two things. We cannot enforce that
        # without a scope stack. Our workaround is to allow an infinite number
        # of these and hope the user can keep track of when there are too many.
        patterns:
          - name: keyword.operator.range.fish
            match: \.\.

          - include: "#command-substitution"

          - include: "#variable-expansion"

          - include: "#string-quoted"

          # There's no need to apply meta.string.unquoted to anything inside of
          # an index expansion, as if it needs to be applied then it would have
          # been handled already. The fact index expansion can appear inside of
          # quotes (after a variable expansion) makes it tricky to decide what
          # is or isn't "unquoted"
          - name: constant.numeric.fish
            match: '{{int}}(?=[{{param_sep}}\]]|\.\.)'

          # Anything else is invalid
          - name: invalid.illegal.index.fish
            match: \S

  string:
    patterns:
      - include: "#string-quoted"
      - include: "#string-unquoted"

  string-quoted:
    patterns:
      - name: string.quoted.single.fish
        begin: \'
        beginCaptures:
          "0": { name: punctuation.definition.string.begin.fish }
        end: \'
        endCaptures:
          "0": { name: punctuation.definition.string.end.fish }
        patterns:
          # Only accepted escapes are \' and \\
          - name: constant.character.escape.fish
            match: \\[\'\\]

      - name: string.quoted.double.fish
        begin: \"
        beginCaptures:
          "0": { name: punctuation.definition.string.begin.fish }
        end: \"
        endCaptures:
          "0": { name: punctuation.definition.string.end.fish }
        patterns:
          - include: "#string-quoted-contents"

  string-quoted-contents:
    # Describe contents of a quoted string separately for ease of recursion.
    patterns:
      # Only accepted escapes are \<newline>, \", \\, and \$
      - name: constant.character.escape.fish
        match: \\[\n\"\\$]

      # Command substitution - replace the string scope with string.interpolated
      # (how shell-unix-bash.tmLanguage.json does it)
      - name: string.interpolated.dollar.fish
        begin: \$\(
        beginCaptures:
          "0": { name: punctuation.definition.string.begin.shell }
        end: \)
        endCaptures:
          "0": { name: punctuation.definition.string.end.shell }
        patterns:
          - include: "#command-substitution"
          - include: $self

      # Variable expansion is the only expansion accepted
      - include: "#variable-expansion"

  string-unquoted:
    patterns:
      - name: meta.string.unquoted.fish
        # Begin unquoted string if not whitespace, control operator, quoted
        # string, or variable expansion
        begin: (?![{{param_sep}}('"$])
        # End unquoted string at anything that can't be in one
        end: (?=[{{param_sep}}('"$])
        patterns:
          - include: "#string-unquoted-contents"

  string-unquoted-contents:
    patterns:
      - include: "#string-unquoted-contents-escapes"

      # Changed in fish 3.0: an empty set of braces will not be brace-expanded,
      # but print literally, however whitespace will disappear. Braces were not
      # allowed to contain whitespace before, so this structure is invalid prior
      # to fish 3.0
      - match: (\{)({{ws_sep}}+)(\})
        captures:
          "1": { name: meta.braces.literal.empty.fish }
          "2": { name: meta.braces.literal.empty.ignored-whitespace.fish }
          "3": { name: meta.braces.literal.empty.fish }

      # This is a special case of the above where the braces don't contain
      # whitespace. This was valid prior to fish 3.0, but the behaviour changed
      - name: meta.braces.literal.empty.fish
        match: \{\}

      # Changed in fish 3.1: a set of braces that doesn't contain `,` or a
      # variable expansion will not be brace-expanded, but print literally
      # including all content.
      - name: meta.braces.literal.non-empty.fish
        begin: \{(?=[^,$\{]+(?:\n|\\\n|\}))
        # All operators are treated as literals inside of the braces. Only `)`
        # is invalid.
        end: (\})|(\).*)
        endCaptures:
          "1": { name: meta.braces.literal.non-empty.fish }
          "2": { name: invalid.illegal.operator.fish }
        patterns:
          # Important - this includes newlines!
          - name: meta.braces.literal.non-empty.ignored-whitespace.fish
            match: \s+
          # Wrap up all the normal argument stuff, and re-allow numerics
          - name: meta.braces.literal.non-empty.fish
            begin: (?!\s)
            end: '(?=[\s\}])|({{real}})(?=$|[\s\}])'
            endCaptures:
              "1": { name: constant.numeric.fish }
            patterns:
              - include: "#command-substitution"
              - include: "#variable-expansion"
              - include: "#string-quoted"
              # Prevent doubling the meta.string.unquoted string scope
              - include: "#string-unquoted-contents"

      # Real brace expansion
      # Since fish 3.0: all whitespace including newlines is permitted
      - name: meta.braces.brace-expansion.fish
        begin: \{
        beginCaptures:
          "0": { name: punctuation.section.braces.begin.fish }
        # All operators are treated as literals inside of the braces. Only `)`
        # is invalid.
        end: (\})|(\).*)
        endCaptures:
          "1": { name: punctuation.section.braces.end.fish }
          "2": { name: invalid.illegal.punctuation.section.fish }
        patterns:
          - name: punctuation.section.braces.separator.fish
            match: \,

          # Important - this includes newlines!
          - name: meta.braces.brace-expansion.ignored-whitespace.fish
            match: \s+

          - include: "#command-substitution"

          - include: "#variable-expansion"

          # Unescaped spaces aren't allowed, as technically that separates the
          # braces into two separate arguments. Don't consume a newline though,
          # so the scope end capture can get it
          - name: invalid.illegal.whitespace.fish
            match: (?:{{ws_sep}}+)

          # Manually recreate the string rule with a numeric match, extra logic
          # in unquoted strings, and don't repeat the meta.string.unquoted scope
          - include: "#string-quoted"

          - name: constant.numeric.fish
            match: '{{real}}(?=$|[{{param_sep}}]|\}|\,)'

          - begin: (?![{{param_sep}}'"])
            end: (?=[{{param_sep}}'"]|\}|\,)
            # Begin/end string as before with the addition of breaking at a '}'
            # or ','
            patterns:
              # Escaped ','
              - name: constant.character.escape.fish
                match: \\\,

              # Prevent doubling the meta.string.unquoted string scope
              - include: "#string-unquoted-contents"

      - name: meta.wildcard-expansion.fish
        match: (\*\*)|(\*)|(\?)
        captures:
          "1": { name: keyword.operator.double-star.fish }
          "2": { name: keyword.operator.single-star.fish }
          "3": { name: keyword.operator.question-mark.fish }

  string-unquoted-contents-escapes:
    patterns:
      # This list follows the order given in official fish documentation.
      # Technically, `~` and `%` only *need* to be escaped at the front of a
      # parameter, but are always *treated* as escaped, even within a parameter.
      - name: constant.character.escape.fish
        match: |-
          (?x)
          (?# single-character escapes)
          \\[abefnrtv $\\*?#(){}\[\]<>^&|;"']
          |
          (?# tilde and percent sign)
          \\[~%]
          |
          (?# hex ASCII)
          \\[xX][0-9A-Fa-f]{1,2}
          |
          (?# octal)
          \\[0-7]{1,3}
          |
          (?# 16-bit Unicode)
          \\u[0-9A-Fa-f]{1,4}
          |
          (?# 32-bit Unicode)
          \\U[0-9A-Fa-f]{1,8}
          |
          (?# control characters)
          \\c[?-~]

      - name: constant.character.escape.newline.fish
        match: \\\n
